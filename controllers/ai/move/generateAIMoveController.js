// controllers/ai/move/generateAIMoveController.js
const OpenAI = require("openai");
const {
  convertAlgebraicToIndex,
  isMovePossibleInternal,
  indexToAlgebraic,
  getAllLegalMoves,
} = require("../../moves/moveHelpers");
const { createBoardMatrix } = require("./genAIMoveHelper");

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});
// console.log("openai:", openai);

const parseAIMove = (responseText, boardState, currentTurn) => {
  // console.log(
  //   `parseAIMove exec: responseText: ${responseText}, boardState: ${boardState}, currentTurn: ${currentTurn}`
  // );

  const movePattern = /^([a-h][1-8])([a-h][1-8])\s*\((\w+)\)$/;
  // console.log("parseAIMove movePattern", movePattern);
  const match = responseText.match(movePattern);
  // console.log("parseAIMove match", match);

  if (match) {
    const fromSquare = match[1];
    const toSquare = match[2];
    const pieceType = match[3];
    // console.log(
    //   `parseAIMove match block: fromSquare: ${fromSquare}, toSquare: ${toSquare}, pieceType: ${pieceType}`
    // );

    const fromIndex = convertAlgebraicToIndex(fromSquare);
    const toIndex = convertAlgebraicToIndex(toSquare);
    // console.log(
    //   `parseAIMove match block: fromIndex: ${fromIndex}, toIndex: ${toIndex}`
    // );

    if (fromIndex === -1 || toIndex === -1) {
      console.error("Error: Invalid move generated by AI - Invalid index.");
      return null;
    }

    const movingPiece = boardState[fromIndex];
    // console.log("parseAIMove match block: movingPiece", movingPiece);
    if (!movingPiece) {
      console.error(
        `Error: No piece found at the source (${fromSquare}) for the AI move: ${responseText}.`
      );
      return null;
    }

    if (movingPiece.player !== currentTurn) {
      console.error(
        `Error: AI attempted to move a piece that does not belong to Black. AI move: ${responseText}, Actual Piece Player: ${movingPiece.player}, Expected Player: ${currentTurn}`
      );
      return null;
    }

    if (movingPiece.type.toLowerCase() !== pieceType.toLowerCase()) {
      console.error(
        `Error: AI attempted to move an incorrect piece type. AI move: ${responseText}, Actual Piece: ${movingPiece.type}, Expected Piece Type: ${pieceType}`
      );
      return null;
    }

    if (!isMovePossibleInternal(fromIndex, toIndex, movingPiece, boardState)) {
      console.error("Error: Invalid move according to piece rules.");
      return null;
    }

    return {
      from: fromIndex,
      to: toIndex,
      piece: movingPiece.type,
    };
  }

  console.error("Unable to parse AI move response:", responseText);
  return null;
};

exports.generateAIMove = async (game, boardState, fen, difficultyLevel) => {
  // console.log("generateAIMove fen:", fen);
  const previousMoves = game.moves
    .map((move) => {
      return `${indexToAlgebraic(move.from)}${indexToAlgebraic(move.to)} (${
        move.piece
      })`;
    })
    .join(", ");
  // console.log("generateAIMove previousMoves:", previousMoves);
  console.log("generateAIMove difficultyLevel:", difficultyLevel);

  const legalMoves = getAllLegalMoves(boardState, 2);
  const boardMatrix = createBoardMatrix(boardState);

  let temperature;

  if (difficultyLevel === "easy") {
    temperature = 1.0; // Moderate randomness
  } else if (difficultyLevel === "medium") {
    temperature = 0.5; // Moderate randomness
  } else if (difficultyLevel === "hard") {
    temperature = 0.1; // Low randomness
  } else {
    temperature = 0.5; // Default value
  }

  let difficultyInstructions;
  if (difficultyLevel === "easy") {
    difficultyInstructions =
      "You are a begginger chess player and want to win the game, but trying all the possible moves before yop ustart to attack but keep your king safe.";
  } else if (difficultyLevel === "medium") {
    difficultyInstructions =
      "You are an intermediate chess player. Choose a good move for Black. You need to win the game, but do not lose much of your own pieces.";
  } else if (difficultyLevel === "hard") {
    difficultyInstructions =
      "You are a chess master and always seek the best move to win the game shortly";
  } else {
    difficultyInstructions = "";
  }

  console.log("generateAIMove temperature:", temperature);
  console.log("generateAIMove difficultyInstructions:", difficultyInstructions);

  const prompt = [
    {
      role: "system",
      content: `
You are a chess engine that provides valid chess moves in the specific format 'fromSquare toSquare (pieceType)' without any extra details.

${difficultyInstructions}

Given the current board state and the list of legal moves, you should:

- Choose the best move for Black from the provided list of legal moves.
- Ensure the move follows all standard chess rules.
- Make new move based on previous and the next that you can do to get closer to winning the game, but do not forget about defense.
- Do not choose moves that would leave your own king in check.
- Do not repeat invalid moves or previous moves.
- Provide only one move in the specified format.
- The move must be from the provided list of legal moves.

The previous moves are: ${
        previousMoves ? previousMoves : "No previous moves have been made"
      }.

**Current board state:**
\`\`\`
${boardMatrix}
\`\`\`

**Legal moves for Black:**
${legalMoves.join(", ")}

Provide the next best move for Black in the format 'fromSquare toSquare (pieceType)'.
  `,
    },
  ];

  try {
    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: prompt,
      max_tokens: 50,
      temperature: temperature,
    });

    if (
      !completion.choices ||
      !completion.choices[0] ||
      !completion.choices[0].message ||
      !completion.choices[0].message.content
    ) {
      console.error("Error: Invalid response from AI move generation.");
      return null;
    }

    const reply = completion.choices[0].message.content.trim();
    // console.log("generateAIMove reply:", reply);

    const aiMove = parseAIMove(reply, boardState, 2);
    // console.log("generateAIMove aiMove:", aiMove);

    return aiMove;
  } catch (error) {
    console.error("Error generating AI move:", error);
    return null;
  }
};
